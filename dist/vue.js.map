{"version":3,"file":"vue.js","sources":["../src/compiler/parse.js","../src/compiler/index.js","../src/utils.js","../src/globalAPI.js","../src/observe/array.js","../src/observe/dep.js","../src/observe/index.js","../src/observe/watcher.js","../src/state.js","../src/vdom/index.js","../src/vdom/patch.js","../src/lifecycle.js","../src/init.js","../src/index.js"],"sourcesContent":["// 标签名：第一个字符+后面的字符；第一个字符不能以数字开头\n// 字符串的两个\\\\是什么？表示转义，字符串中的转义，前一个\\表示转义后面的\\\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`;\n// (?:${ncname}\\\\:)?\n// 第一个?:表示匹配但是不记住匹配项；\n// 为啥不要记住匹配性，因为需要加()分组后表示前面一半是命名空间可有可无，但是又不想铺获$1的值\n// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions#special-non-capturing-parentheses\n// (?:${ncname}\\\\:)? 第二个？表示可有可无\n// 外面的分组\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\n\n// 注意前面的开头^，必须是开始匹配\n// <1_xxx 不能以数字开头\n// <_xxx 自定义标签，都是以_开头 webcomponent\n// <xxx\n// <namespace:yyy 命名空间\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\n// console.log(startTagOpen);\n\n// 注意前面的开头^，必须是开始匹配\n// 匹配到的是</xxx>\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\n// console.log(endTag);\n\n// 注意前面的开头^，必须是开始匹配\n// a=b 没有空格\n// a = b =前后有空格\n// <xx a = b a前面也有空格\n// ([^\\s\"'<>\\/=]+)表示前面的属性名或者属性值，除了\"'<>那些字符都可以的字符\n// <xxx disabled disabled属性只有前面的部分没有后面的部分（=xxx）\n// (?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))? 第一个()为了后面加？表示属性值可有可无\n// \"([^\"]*)\"+ 以双引号包的非\"的多个字符 <xx a = \"b\" 左边双引号右边双引号中间不是双引号就可以\n// '([^']*)'+ 以单引号包的非'的多个字符 <xx a = 'b' 左边单引号右边单引号中间不是单引号就可以\n// ([^\\s\"'=<>`]+) 除了\\s\"'=<>`的任意多个字符  <xx a = b 属性也可以不加单引号或者双引号\nconst attribute =\n  /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的\n// 第一个分组就是属性的key value就是分组3/分组4/分组5\n// console.log(attribute);\n\n// 注意前面的开头^，必须是开始匹配\n// <div> <br/> 标签结束可能是> 也可能是/>\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // {{aaaaaa}} 匹配到的时候表达式的变量\n\n// 对模版进行编译\n// vue3不是采用的正则匹配了，是一个一个字符匹配\n// 思路： 每解析一个标签就删除一个标签，每解析一个属性就删除一个属性；字符串被截取完了就结束了\nexport function parseHTML(html) {\n  // 抽象语法树\n  /*\n  {\n    tag:'div',\n    type:1,\n    children:[{tag:'span',type:1,attrs:[],parent:'div对象'}],\n    attrs:[{name:'zf',age:10}],\n    parent:null\n  }\n*/\n\n  // 用于存放元素的栈，利用栈来创建一棵树\n  let stack = [];\n  // 节点类型-标签类型\n  const ELEMENT_TYPE = 1;\n  // 节点类型-文本类型\n  const TEXT_TYPE = 3;\n  // 根节点\n  let root;\n  // 指向栈中最后一个元素\n  let currentParent;\n\n  function createASTElement(tagName, attrs) {\n    return {\n      tag: tagName,\n      type: ELEMENT_TYPE,\n      children: [],\n      attrs,\n      parent: null,\n    };\n  }\n\n  // 开始标签 <div><span><a>text</a></span></div>\n  function start(tagName, attrs) {\n    // console.log(tagName, attrs);\n    // 创建一个ast节点\n    let element = createASTElement(tagName, attrs);\n    // 看下是否是空树\n    if (!root) {\n      // 如果为空树，当前节点是树的根节点\n      root = element;\n    }\n    // 进栈构建父子关系\n    // 放在end时候执行该逻辑也行\n    // if (currentParent) {\n    //   element.parent = currentParent;\n    //   currentParent.children.push(element);\n    // }\n    stack.push(element);\n    // currentParent为栈中的最后一个元素\n    currentParent = element;\n  }\n\n  // 结束标签\n  function end(tagName) {\n    // console.log(tagName);\n    // 当前标签结束就弹栈；弹出栈中的最后一个元素\n    let element = stack.pop();\n    // currentParent为栈中的最后一个元素\n    currentParent = stack[stack.length - 1];\n    // 出栈构建父子关系\n    // 放在start入栈的时候执行该逻辑也行\n    if (currentParent) {\n      // 当前标签结束的这个元素的parent就是栈中的最后一个元素\n      element.parent = currentParent;\n      // 栈中的最后一个元素的儿子就是当前弹栈弹出来的节点\n      currentParent.children.push(element);\n    }\n  }\n\n  // 文本；文本不需要放到栈中，文本直接放到currentParent节点的children中\n  function chars(text) {\n    // console.log(text);\n    // 去掉空，可以优化为如果空格超过2个就删除2个以上的空格\n    text = text.replace(/\\s/g, \"\");\n    // 不是节点直接的换行等空文本\n    if (text) {\n      // 文本节点直接放到当前栈的最后一个节点的children中，作为他的儿子\n      currentParent.children.push({\n        type: TEXT_TYPE,\n        text,\n        parent: currentParent,\n      });\n    }\n  }\n\n  // html字符串前进n个字符：例如截掉已经捕获到的开头标签名、属性名和属性值、结束标签\n  function advance(n) {\n    html = html.substring(n);\n  }\n\n  // 解析开始标签，包括解析标签名和所有属性\n  function parseStartTag() {\n    // 匹配开始标签名\n    const start = html.match(startTagOpen);\n    if (start) {\n      const match = {\n        tagName: start[1],\n        attrs: [],\n      };\n\n      // html字符串截掉tagName\n      // start[0] =>\n      advance(start[0].length);\n\n      // 捕获当前标签的所有属性\n      let attr, end;\n      // 当前捕获到了属性标签并且不是当前标签的结束\n      while (\n        !(end = html.match(startTagClose)) &&\n        (attr = html.match(attribute))\n      ) {\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5],\n        });\n        // attr[0] => id=\"app\"\n        advance(attr[0].length);\n      }\n\n      // html字符当前到了当前标签的结束位置 > 或者 />\n      if (end) {\n        // 移除结束位置\n        advance(end[0].length);\n        // 返回匹配到的当前节点\n        return match;\n      }\n    }\n  }\n\n  // html字符串肯定是以<开头\n  while (html) {\n    let textEnd = html.indexOf(\"<\");\n    // <div>hello</div> indexOf等于0\n    // 如果textEnd为0，表明当前html字符串处于开始标签处或者结束标签处\n    // 如果textEnd大于0，表明当前html字符串处于文本节点或者空文本处，>处于文本节点的结束位置\n    if (textEnd === 0) {\n      // 如果indexOf的索引是0，则说明是一个开始标签或者结束标签\n      // 解析开始标签：<div a=b c=d>\n      const startTagMatch = parseStartTag();\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs);\n        // 继续解析当前标签下的子开头标签\n        // 例如<div a=b c=d><span>txt</span></div>中的下一个标签是<span>\n        continue;\n      }\n\n      // 解析到最深的子节点的结束标签\n      // 例如<div a=b c=d><span>txt</span></div>中的</span>\n      const endTagMatch = html.match(endTag);\n      if (endTagMatch) {\n        advance(endTagMatch[0].length);\n        end(endTagMatch[1]);\n        continue;\n      }\n      // 先让他暂停\n      // break;\n    }\n\n    // 当前html字符串处于文本标签处，因为结束标签>的index>0\n    // 标签中的空格也是文本\n    // <div a=b c=d>\n    //    <span>txt</span>\n    // </div>\n    // hello</div> indexOf大于0 说明是文本\n    let text;\n    if (textEnd > 0) {\n      text = html.substring(0, textEnd);\n    }\n    if (text) {\n      advance(text.length);\n      chars(text);\n    }\n  }\n\n  // html为空\n  // console.log(\"html\", html);\n  // root\n  // console.log(\"root\", root);\n\n  return root;\n}\n","import { parseHTML } from \"./parse\";\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // {{aaaaaa}} 匹配到的时候表达式的变量\n\n/**\n *\n *  <div style=\"color:red\">hello {{name}} <span></span></div>\n *  render(){\n *    return _c('div',{style:{color:'red'}},_v('hello'+_s(name) + 'age' + _s(age)),_c('span',undefined,''))\n *  }\n */\n\n// 如果是文本就创建文本节点；如果是标签元素就调用codegen\nfunction gen(node) {\n  // 标签类型\n  if (node.type == 1) {\n    return codegen(node);\n  } else {\n    // 文本类型节点\n    let text = node.text;\n    // 纯文本类型\n    if (!defaultTagRE.test(text)) {\n      return `_v(${JSON.stringify(text)})`;\n    }\n    // 包含{{}}的类型\n    // 变量name需要转成字符串_s(name) 用+拼接\n    // {{name}} hello {{name}} => _v(_s(name) + 'hello' + _s(name))\n    // console.log(\"文本节点：\", text);\n\n    let tokens = [];\n    let match;\n    // exec方法的特殊点：\n    // 现象：当正则表达式里面有g的时候，连续执行两次结果不一样: let reg = /a/g; reg.exec('abc'); reg.exec('abc');\n    // 原因：执行完一次后 reg.lastIndex变成1了，从第一个字符再往后找就找不到了\n    // 解决方法：每次重新执行exec的时候需要把reg.lastIndex重置为0\n    defaultTagRE.lastIndex = 0;\n    // 记录上一个匹配内容后的位置，算上字符串本身的长度\n    let lastIndex = 0;\n    while ((match = defaultTagRE.exec(text))) {\n      // console.log(\"match\", match);\n      // 匹配的位置\n      let index = match.index;\n\n      // 中间有一个文本字符串\n      // {{name}} hello {{age}} age\n      // lastIndex就是{{name}}的结尾位置，index就是{{name}}的开头位置\n      if (index > lastIndex) {\n        // 把中间的hello内容放到tokens中\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n      }\n\n      tokens.push(`_s(${match[1].trim()})`);\n      lastIndex = index + match[0].length;\n    }\n\n    // 最后的文本字符串\n    // {{name}} hello {{age}} age中的age\n    // 从{{age}}的结束位置截取到最后\n    if (text.length > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex)));\n    }\n\n    // console.log(tokens);\n\n    return `_v(${tokens.join(\"+\")})`;\n  }\n}\n\n// 生成儿子节点\nfunction getChildren(el) {\n  const children = el.children;\n  if (children) {\n    return `${children.map((c) => gen(c)).join(\",\")}`;\n  } else {\n    return false;\n  }\n}\n\n// 生成属性\n// attrs [{name: 'id', value: 'wapper'}, {name: 'style', value: 'color: red; font-size: 50px'}]\nfunction genProps(attrs) {\n  let str = \"\";\n  for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i];\n    // 如果attr名称是style\n    // {name: 'style', value: 'color: red; font-size: 50px'}\n    // 'color: red; font-size: 50px' => {color: red, font-size: 50px}\n    if (attr.name === \"style\") {\n      let obj = {};\n      attr.value.split(\";\").forEach((item) => {\n        let [key, value] = item.split(\":\");\n        obj[key] = value;\n      });\n      attr.value = obj;\n    }\n    // JSON.stringify把vue转成字符串\n    str += `${attr.name}:${JSON.stringify(attr.value)},`;\n  }\n  return `{${str.slice(0, -1)}}`;\n}\n\n// 生成code\nfunction codegen(el) {\n  // console.log(\"el\", el);\n\n  // 生成改节点的孩子，如果有孩子就加个,没孩子就不加了\n  let children = getChildren(el);\n\n  let code = `_c('${el.tag}', ${\n    el.attrs.length > 0 ? genProps(el.attrs) : \"undefined\"\n  }${children ? `,${children}` : \"\"}\n  )`;\n\n  return code;\n}\n\nexport function compileToFunctions(template) {\n  // console.log(template);\n\n  // 1. 将template转换成AST语法树\n  let ast = parseHTML(template);\n  // console.log(ast);\n\n  // 2. 生成render方法，render方法执行后返回的结果就是虚拟DOM\n  let code = codegen(ast);\n  // console.log(\"code\", code);\n\n  // 模版引擎的原理： with + new Function\n  // _c('div',{style:{color:'red'}},_v('hello'+_s(name)),_c('span',undefined,''))\n  // 用with？为了取值方便；解决_c _v _s从哪儿取的问题，不用都得vm._c vm._v vm._s了\n  // 为啥是this而不是vm? render函数被谁调用就是谁； this是谁就从谁的上面取_c _v _s\n  let render = `with(this){return ${code}}`;\n  let renderFn = new Function(render);\n  // 生成render函数，需要调用；分成两块：生成函数、调用函数\n  return renderFn;\n}\n\n// 最终的render函数\n/*\nfunction render() {\n  with (this) {\n    _c(\n      \"div\",\n      { style: { color: \"red\" } },\n      _v(\"hello\" + _s(name)),\n      _c(\"span\", undefined, \"\")\n    );\n  }\n}\n*/\n\n// render函数调用绑定作用域\n// render.call(vm);\n","// 策略模式\nconst strats = {};\nconst LIFECYCLES = [\"beforeCreate\", \"created\"];\nLIFECYCLES.forEach((hook) => {\n  strats[hook] = function (p, c) {\n    //子存在\n    if (c) {\n      // 子存在，父也存在（父存在那么父就是数组），就把子和父拼在一起\n      if (p) {\n        return p.concat(c);\n      } else {\n        // 子存在但是父不存在，则把儿子包装成数组\n        return [c];\n      }\n    } else {\n      // 子不存在只有父，直接返回父\n      return p;\n    }\n  };\n});\n\n// data的props merge策略\n// strats.data = function (p, c) {};\n\n// 计算属性的props merge策略\n// strats.computed = function (p, c) {};\n\n// ...剩下的策略\n\nexport function mergeOptions(parent, child) {\n  let options = {};\n\n  // 不能这么做，这么做合并不出来数组；以为直接覆盖了 {created: [fn, fn]}\n  // let options = { ...parent, ...child };\n\n  // 先遍历父的所有key\n  for (const key in parent) {\n    if (parent.hasOwnProperty(key)) {\n      mergeField(key);\n    }\n  }\n\n  // 再遍历父亲上没有的儿子上的key\n  for (const key in child) {\n    // 父亲上不存在的key\n    if (!parent.hasOwnProperty(key)) {\n      mergeField(key);\n    }\n  }\n\n  function mergeField(key) {\n    // 策略上有就走策略模式，没有就走默认\n    if (strats[key]) {\n      options[key] = strats[key](parent[key], child[key]);\n    } else {\n      // 策略没有提供，就走默认策略；以儿子为主\n      // 优先考虑儿子上的属性，再采用父亲的属性\n      options[key] = child[key] || parent[key];\n    }\n  }\n\n  return options;\n}\n","import { mergeOptions } from \"./utils\";\n\nexport function initGlobalAPI(Vue) {\n  // Vue的静态属性\n  Vue.options = {};\n\n  // Vue的静态方法，把选项合并到了Vue.options上\n  Vue.mixin = function (mixin) {\n    // this是谁？\n    // 我们期望将用户的选项mixin和全局的Vue.options按照一定的策略合并\n    // 第一次 全局空对象{} 和 用户传的{created: function(){}}合并 => {created: [fn]}\n    // 第二次 第一次合并的结果{created: [fn]} 和 用户传的{created: function(){}}合并  => {created: [fn, fn]}\n    this.options = mergeOptions(this.options, mixin);\n    // 为了链式调用\n    return this;\n  };\n}\n","// 我们希望重新数组的部分方法\n// 思路： 改变原型链、AOP函数劫持：内部调用原本的方法前后新加逻辑\n\n// 获取数组的原型\nlet oldArrayProtoMethods = Array.prototype;\n\n// 基于Array.prototype创建一个新的对象\n// 让数组类型的value的__proto__指向下面的对象，等于修改了原型链\n// arrayMethods.__proto__ = oldArrayProtoMethods;\n// value.__proto__ == arrayMethods\nexport let arrayMethods = Object.create(oldArrayProtoMethods);\n\n// 所有的变异方法7个：能修改原数组的方法： 对头（尾）\n// concat、slice不能修改原数组\nlet methods = [\"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"splice\"];\n\nmethods.forEach((method) => {\n  // arrayMethods上面的加的方法只会影响arrayMethods上面的方法，不会覆盖Array.prototype上的原本的方法\n  // 通过原型链找到了arrayMethods的push就不会继续去找Array.prototype上的push方法\n  // 重新arrayMethods上的7个方法\n  // arr.push(1,2,3)\n  arrayMethods[method] = function (...args) {\n    // 这里重写了数组的方法\n    // 旧方法: 在新的方法里面调用\n    // this就是arr\n    const result = oldArrayProtoMethods[method].apply(this, args); // 内部调用原来的方法，函数的劫持，面向切片变成\n\n    // console.log(\"array method: \", method);\n\n    // 底下为AOP的增加自己的逻辑\n\n    // this是arr，谁调用的push就是谁\n    // this就是Observer中的那个value\n    const ob = this.__ob__;\n    // 新增的数组\n    let inserted;\n    // push和unshift会新增数据，新增的数据也需要劫持\n    // splice也可能会新增数据\n    switch (method) {\n      case \"push\":\n      case \"unshift\":\n        inserted = args; // arr.unshift(1, 2, 3) // 新增的内容是一个数组\n        break;\n      case \"splice\":\n        inserted = args.slice(2); // arr.splice(0, 1, {a: 1}, {b: 2}) 第2个参数后面的参数是新增的内容是数组\n      default:\n        break;\n    }\n    // 对数组类型的数据进行观察劫持\n    if (inserted) {\n      // 对新增的数据（数组）再次进行观测劫持\n      ob.observeArray(inserted);\n    }\n\n    // 数组变化了，通知相应的watcher实现更新逻辑\n    ob.dep.notify();\n\n    return result;\n  };\n});\n","let id = 0;\n\n// 被观察者，属性就是被观察者；属性的值发生变化后会通知所有的观察者更新\n\n// 属性的dep要收集watcher\nclass Dep {\n  constructor() {\n    // 唯一id\n    this.id = id++;\n    // 这里存放着当前属性对应的watcher有哪些\n    this.subs = [];\n  }\n\n  // 保证dep和watcher都不重复，保证dep和watcher双向维护\n  depend() {\n    // 这里不希望放置不重复的watcher；而且不只是一个单向的关系，dep -> watcher\n    // 也得让wather记录dep\n    // this.subs.push(Dep.target);\n\n    // 我们希望dep和watcher相互维护各自的引用，相互记忆\n    // 把dep传给了watcher\n    Dep.target.addDep(this); // 让watcher记住dep，在watcher中记住dep的时候去了重同时也让dep记录了watcher\n\n    // dep和watcher是多对多的关系\n    // 一个属性在多个组件中使用 一个dep对应多个watcher\n    // 一个组件中有多个属性 一个watcher包含多个dep\n  }\n\n  addSubs(watcher) {\n    this.subs.push(watcher);\n  }\n\n  notify() {\n    // 告诉所有watcher更新\n    this.subs.forEach((watcher) => watcher.update());\n  }\n}\n\n// target为什么不挂载到原型上，反而是个静态变量呢？因为没必要通过实例来访问，只是一个作为一个全局变量\n// 静态属性 - 相当于全局变量\n// 记录\nDep.target = null;\n\n// 用栈来维护watcher\nlet stack = [];\n\n// 渲染watcher先入栈，然后计算属性watcher入栈\nexport function pushTarget(watcher) {\n  // 压栈\n  stack.push(watcher);\n  Dep.target = watcher;\n}\n\nexport function popTarget() {\n  // 出栈\n  stack.pop();\n  // 如果最后一个弹栈后，取最后一个就Dep.target = undefined\n  Dep.target = stack[stack.length - 1];\n}\n\nexport default Dep;\n","import { arrayMethods } from \"./array\";\nimport Dep from \"./dep\";\nclass Observer {\n  // 观测值\n  constructor(value) {\n    /**\n     * data() {\n     *    return {\n     *      arr: [1, 2, 3, { a: 1 }],\n     *      obj: { b: 1 },\n     *    };\n     *  },\n     */\n    // 给每个对象增加依赖收集: 给arr和boj增加依赖收集\n    this.dep = new Dep();\n\n    // 给所有响应式数据增加标识，并且可以在响应式上获取Observer实例上的方法\n    // 如果数据上已经有了__ob__标识，证明已经被代理过了\n    // 增加__ob__属性为this，目的是可以在value上取到this从而调用Observer类上的方法\n    // 等同于value.__ob__ = this；但是没有控制可以枚举性，会导致下面defineReactive的时候死循环\n    // 值是this，但是不可枚举，循环的时候无法获取，从而解决了死循环的问题\n    Object.defineProperty(value, \"__ob__\", {\n      enumerable: false,\n      configurable: false,\n      value: this,\n    });\n\n    if (Array.isArray(value)) {\n      // 重新数组的7个变异方法，为啥是变异方法，因为会修改原数组\n\n      // 需要保留数组原有的方法，并且可以重写部分方法\n      value.__proto__ = arrayMethods; // 重写数组原型方法\n      // 数组里面的对象引用类型也需要进行劫持\n      this.observeArray(value); // 如果数组中方的是对象，可以监控到对象的改变\n    } else {\n      // 遍历\n      this.walk(value);\n    }\n  }\n\n  // 循环递归（性能差的原因）对象，对对象的所有属性进行劫持\n  walk(data) {\n    // 让对象上的所有属性依次进行观测\n    let keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let value = data[key];\n      // \"重新定义\"属性\n      defineReactive(data, key, value);\n    }\n  }\n\n  // 观测数组\n  observeArray(data) {\n    data.forEach((item) => observe(item));\n  }\n}\n\n// 对数组的每一项进行依赖收集\n// 深层次的嵌套会递归，递归多了性能会差，不存在的属性监控不到，存在的属性要重新方法；vue3 => proxy\nfunction dependArray(value) {\n  for (let i = 0; i < value.length; i++) {\n    let current = value[i];\n    current.__ob__ && current.__ob__.dep.depend();\n    // 如果item仍然是数组，递归进行依赖收集\n    if (Array.isArray(current)) {\n      dependArray(current);\n    }\n  }\n}\n\n// 要暴露的方法，所以不能放到Observer类里面\n// 闭包\nexport function defineReactive(data, key, value) {\n  // 深度属性劫持\n  // 如果value还是object类型，继续调用observe进行递归劫持\n  // 返回的childOb上有dep属性，用来收集依赖\n  let childOb = observe(value);\n\n  // 每一个属性都有一个dep\n  let dep = new Dep();\n\n  // 缺点：Object.defineProperty只能劫持已经存在的属性，对于新增的和删除的操作监听不到\n  // 所以vue中单独写了一些api如$set, $delete来实现属性的新增的和删除后，仍然能做到数据劫持\n  Object.defineProperty(data, key, {\n    get() {\n      // console.log(`get key ${key}`);\n      // 什么时候Dep.target会有值？模版中使用了的变量，在调用_render()方法的时候就会在Dep.target加上值\n      // 用到了的属性才会被收集，在data中定义了，但是视图组件中没有用到也不会被收集\n      if (Dep.target) {\n        // 让这个属性的收集器记住当前的watcher\n        dep.depend();\n        if (childOb) {\n          // 让数组和对象本身也要实现依赖收集\n          childOb.dep.depend();\n\n          // 如果当前value是数组，也需要对数组的每个成员进行依赖收集\n          if (Array.isArray(value)) {\n            dependArray(value);\n          }\n        }\n      }\n\n      // 取值的时候会执行get\n      // 闭包，value不会销毁，能取得到\n      return value;\n    },\n    set(newValue) {\n      // 设值的时候会执行set\n      if (newValue == value) return;\n\n      // console.log(`set key ${key} ${newValue}`);\n\n      // 再次劫持\n      // 深度属性劫持\n      // 如果设置的属性的value仍然是对象，继续递归进行新增属性的响应式\n      observe(newValue);\n\n      value = newValue;\n\n      // 属性一变化，就通知更新\n      dep.notify();\n    },\n  });\n}\n\nexport function observe(data) {\n  // 对这个对象进行劫持\n\n  if (typeof data !== \"object\" || data === null) {\n    return; // 只对对象进行劫持\n  }\n\n  // data上有__ob__标识证明已经被观察过了，直接返回原本的Observer就可以了\n  if (data.__ob__ instanceof Observer) {\n    return data.__ob__;\n  }\n\n  // 如果一个对象被劫持过了，那就不需要再被劫持了（需要判断一个对象是否被劫持过，可以添加一个实例，用实例来判断是否被劫持过）\n  return new Observer(data);\n}\n","import Dep, { popTarget, pushTarget } from \"./dep\";\n\n// 观察者模式\n// Watcher观察者，观察某个属性，某个属性的值发生变化后 观察者就update\n// 每个属性有一个dep, 属性就是被观察者；属性的值发生变化后会通知所有的观察者更新\n\n// watcher的id\nlet id = 0;\n\n// 1) 当我们创建渲染watcher的时候我们把当前的渲染watcher放到 Dep.target上\n// 2) this.getter()会调用_render()方法，就会走到属性的get方法上\n\n// 不同组件有不同的watcher，目前只有一个，渲染根实例的\nclass Watcher {\n  constructor(vm, exprOrFn, options, cb) {\n    // 唯一标识符\n    this.id = id++;\n    // 组件实例\n    this.vm = vm;\n    // 渲染watcher\n    this.renderWatcher = options;\n\n    if (typeof exprOrFn === \"string\") {\n      // 字符串转函数；不要用箭头函数，避免作用域问题\n      this.getter = function () {\n        return vm[exprOrFn]; // vm.firstname\n      };\n    } else {\n      // callback\n      this.getter = exprOrFn; // getter意味着调用这个函数可以发生取值操作\n    }\n\n    // 记录dep\n    // watcher为什么要记录deps?\n    // 1. 后续实现计算属性会用到\n    // 2. 一些清理工作需要用到: 当组件卸载的时候会把该组件的所有依赖deps清除掉\n    this.deps = [];\n    this.depsId = new Set();\n    // callback回调函数\n    this.cb = cb;\n    // 懒执行\n    this.lazy = options.lazy;\n    // 缓存值，脏值检测；lazy为true的话dirty就是true；\n    this.dirty = this.lazy;\n    // 用户自定watcher\n    this.user = options.user;\n\n    // 如果lazy为true, get不会立即执行了\n    // oldValue\n    this.value = this.lazy ? undefined : this.get();\n  }\n\n  evaluate() {\n    // 获取到用户函数fn的返回值，并且标识为不脏\n    this.value = this.get();\n    this.dirty = false;\n  }\n\n  get() {\n    // 先把当前的watcher放到 Dep.target上\n    // A组件渲染的时候会把A组件的watcher放上来，B组件渲染的时候会把B组件的watcher放上来，\n    // Dep.target = this;\n    pushTarget(this);\n    // 调用vm._update(vm._render()) 就会去vm上取name和age的值\n    const value = this.getter.call(this.vm);\n    // 渲染完毕后就清空\n    // Dep.target = null;\n    popTarget();\n    // 计算属性的getter执行后的返回值，渲染watcher的fn没有返回值\n    return value;\n  }\n\n  // 一个组件 对应着多个属性 重复的属性不应该重复记录 name可能会被引用几次\n  addDep(dep) {\n    let depId = dep.id;\n    if (!this.depsId.has(depId)) {\n      this.deps.push(dep);\n      this.depsId.add(depId);\n      // watcher记住了dep而且去重了，此时dep也记住了watcher\n      dep.addSubs(this);\n    }\n  }\n\n  depend() {\n    let i = this.deps.length;\n    while (i--) {\n      // 让计算属性watcher也收集渲染watcher\n      this.deps[i].depend();\n    }\n  }\n\n  update() {\n    // console.log(\"update\");\n\n    // 执行多次，修改为下面的方面\n    // 重新渲染\n    // this.get();\n    // 如果是计算属性\n    if (this.lazy) {\n      // 依赖得值发生变化了，就标识计算属性是脏值了\n      this.dirty = true;\n    } else {\n      // 解决修改属性执行多次，把watcher放到队列中，然后一次执行\n      queueWatcher(this);\n    }\n  }\n\n  // 真实的渲染\n  run() {\n    let oldValue = this.value;\n    // console.log(\"run\");\n    // 渲染的时候使用最新的vm来渲染的\n    let newValue = this.get(); // vm.name = 最后一次的值\n    // 如果是用户watcher还需要调用回调并传入newValue和oldValue\n    if (this.user) {\n      this.cb.call(this.vm, newValue, oldValue);\n    }\n  }\n}\n\n// 用于存放watcher的队列\nlet queue = [];\n// 类似set防止重复存放watcher，因为一个组件依赖多个属性\nlet has = {};\n// 防抖，只执行最后一次\nlet pending = false;\n\n// 异步批处理\nfunction flushSchedulerQueue() {\n  // 拷贝一份，不要影响原来的watcher的queue\n  let flushQueue = queue.slice(0);\n\n  // clear清理工作\n  // 清理工作为什么放到前面？pending为false的话如果刷新中还有新的任务过来的话，就可以放到队列中\n  queue = [];\n  has = {};\n  pending = false;\n  // 在刷新的过程中如果还有新的watcher，会重新放到queue中\n  flushQueue.forEach((q) => q.run());\n}\n\nfunction queueWatcher(watcher) {\n  const id = watcher.id;\n  if (!has[id]) {\n    has[id] = true;\n    queue.push(watcher);\n    // console.log(\"watcher queue\", queue);\n    // 不管我们的update执行多少次，但是最终只执行一轮刷新操作\n    // 第一个属性过来就设置定时器，第二、三个属性过来的时候就不设置定时器了\n    if (!pending) {\n      // 开启一个定时器，异步执行刷新操作\n      setTimeout(flushSchedulerQueue, 0);\n      // pending为true以后就不能再次添加setTimeout了\n      pending = true;\n    }\n  }\n}\n\n// 封装异步方案，供用户使用和框架内部使用\n// 外部用户使用的时候可以连续写多个vm.$nextTick(() => {})，所以也需要维护队列\nlet callbacks = [];\nlet waiting = false;\n\n// flushCallbacks是异步执行的\nfunction flushCallbacks() {\n  let cbs = callbacks.slice(0);\n  waiting = false;\n  callbacks = [];\n  cbs.forEach((cb) => cb());\n}\n\n// nextTick并不是创建异步任务，而是把异步任务维护到了队列中\n// nextTick只会开启一次异步任务\n// nextTick是异步么？既有同步，又有异步；同步就是把异步任务维护到了队列中，异步就是flushCallbacks是异步执行的\n\n// nextTick没有直接使用某一个api,而是做了优雅的降级\n// 内部优先采用promise(ie不兼容)、和promise.then同等的MutationObserver h5的api；可以考虑ie专享的setImmediate；最后才是setTimout定时器\n// 前面的几个api都是微任务，比setTimout执行的时机快，能更快的看到页面刷新完成\n// setTimout要开启一个新的线程，promise.then只是异步执行代码，性能开销要小\n\nlet timerFunc = null;\n\nif (Promise) {\n  timerFunc = () => {\n    Promise.resolve().then(flushCallbacks);\n  };\n} else if (MutationObserver) {\n  let observer = new MutationObserver(flushCallbacks);\n  let textNode = document.createTextNode(1);\n  // 观察textNode的文本内容发生变化，变化后就执行回调flushCallbacks\n  observer.observe(textNode, {\n    characterData: true,\n  });\n  timerFunc = () => {\n    textNode.textContent = 2;\n  };\n} else if (setImmediate) {\n  timerFunc = () => {\n    setImmediate(flushCallbacks);\n  };\n} else {\n  timerFunc = () => {\n    setTimeout(flushCallbacks);\n  };\n}\n\nexport function nextTick(cb) {\n  // 把任务维护到队列中不是异步的\n  callbacks.push(cb);\n  if (!waiting) {\n    timerFunc();\n    waiting = true;\n  }\n}\n\n// 要给每个属性加一个dep, 目的就是收集watcher\n// 一个视图(视图就是组件)中有多个属性，（n个属性对应一个视图） n个dep对应一个watcher\n// 一个属性对应多个视图组件 1个dep对应多个watcher\n// dep和watcher是多对多的关系\n\nexport default Watcher;\n\n// 一个组件对应一个watcher；\n// 不同的组件有不同的watcher\n// 一个页面中多个组件，对应多个watcher；某个属性变化了，只会通知依赖了该属性的watcher去更新页面\n\n// 组件化的目的是什么？\n// 可复用、方便维护、局部刷新\n// 一个组件一个watcher, 通过拆分组件来减少刷新的范围，某个属性变化了，只会通知依赖了该属性的watcher也就是组件去更新\n","import { observe } from \"./observe\";\nimport Watcher, { nextTick } from \"./observe/watcher\";\nimport Dep from \"./observe/dep\";\n\nexport function initState(vm) {\n  const opts = vm.$options; // 获取所有的选项\n\n  // data初始化\n  if (opts.data) {\n    initData(vm);\n  }\n\n  // 初始化计算属性\n  if (opts.computed) {\n    initComputed(vm);\n  }\n\n  // 初始化watch方法\n  if (opts.watch) {\n    initWatch(vm);\n  }\n}\n\n// 数据代理\nfunction proxy(vm, target, key) {\n  // vm.name\n  Object.defineProperty(vm, key, {\n    get() {\n      // => vm._data.name\n      return vm[target][key];\n    },\n    set(newValue) {\n      vm[target][key] = newValue;\n    },\n  });\n}\n\n// 初始化data\nfunction initData(vm) {\n  let data = vm.$options.data; // data可能是函数和对象\n  // 根组件可以是function也可以对象，组件必须是函数\n  data = typeof data === \"function\" ? data.call(vm) : data; // data是用户返回的对象\n  // 将data挂载到vm的_data，和vm上直接可以取到属性的proxy不一样\n  vm._data = data;\n  // 数据劫持 vue2用的是Object.defineProperty\n  observe(data);\n\n  // vm.xxx =>(代理到)  vm._data.xxx\n  for (let key in data) {\n    proxy(vm, \"_data\", key);\n  }\n}\n\n// 初始化computed\nfunction initComputed(vm) {\n  let computed = vm.$options.computed;\n  // 按计算属性得key存放每个计算属性watcher\n  // 将计算属性watchers保存到vm上\n  const watchers = (vm._computedWatchers = {});\n\n  for (const key in computed) {\n    if (Object.hasOwnProperty.call(computed, key)) {\n      const userDef = computed[key];\n\n      // 创建计算属性Watcher\n      // 我们需要监控计算属性中get的变化，重新计算computed的get方法求新值\n      let fn = typeof userDef === \"function\" ? userDef : userDef.get;\n      // 直接new Watcher的时候就会执行fn方法；渲染Watcher创建的时候就需要执行fn\n      // lazy懒执行，计算属性watcher不能立即执行fn\n      // 计算属性watcher的fn啥时候执行呢？使用fullname的时候才执行，就是渲染watcher的fn执行的时候获取了计算属性的值才会执行\n      /**\n       *  fullname() {\n       *    console.log(\"run fullname\");\n       *    return this.firstname + this.lastname;\n       *  },\n       */\n      // 将属性和watcher对应起来\n      // 计算属性watcher不会导致页面更新\n      watchers[key] = new Watcher(vm, fn, { lazy: true });\n\n      // 给vm定义计算属性key\n      defineComputed(vm, key, userDef);\n    }\n  }\n}\n\nfunction defineComputed(target, key, userDef) {\n  const getter = typeof userDef === \"function\" ? userDef : userDef.get;\n  const setter = userDef.get || (() => {});\n\n  // console.log(getter);\n  // console.log(setter);\n\n  // 给vm定义属性\n  Object.defineProperty(target, key, {\n    get: createComputedGetter(key), // 包装一下get方法\n    set: setter,\n  });\n}\n\n// 每次计算属性取值都会走到get方法\n// 计算属性不会依赖收集，只会让自己的依赖属性去收集依赖\nfunction createComputedGetter(key) {\n  // 我们需要检测是否执行这个getter\n  return function () {\n    // 获取对应属性的watcher\n    const watcher = this._computedWatchers[key];\n    // 如果是脏的就去执行 用户传人的函数\n    if (watcher.dirty) {\n      // 计算属性求值一次后dirty就为false了，下次就不重新求值了，直接返回上次的结果\n      watcher.evaluate();\n    }\n\n    // 计算属性求值后，如果Dep.target还有值\n    // 计算属性watcher出栈后，还要渲染watcher,我们应该让计算属性watcher里面的属性，也去收集上一层的渲染watcher\n    if (Dep.target) {\n      watcher.depend();\n    }\n    // 最后返回的是watcher上的value\n    return watcher.value;\n  };\n}\n\nfunction createWatcher(vm, key, handler) {\n  // 字符串、函数；数组已经在上层处理过了；我们暂时不考虑对象\n  if (typeof handler === \"string\") {\n    handler = vm.$options.methods[handler];\n  }\n\n  // $vm.$watch()\n  return vm.$watch(key, handler);\n}\n\n// 初始化watch\nfunction initWatch(vm) {\n  let watch = vm.$options.watch;\n  // console.log(\"initWatch\", watch);\n  for (let key in watch) {\n    // handler分字符串、函数、数组\n    // vue中handler还可能是对象；我们的实现中先不考虑\n    /***\n     * watch: {\n     *   firstname: {\n     *      handler: function() {\n     *      },\n     *      immediate: true\n     *   }\n     * }\n     *\n     */\n    const handler = watch[key];\n    if (Array.isArray(handler)) {\n      for (let i = 0; i < handler.length; i++) {\n        createWatcher(vm, key, handler[i]);\n      }\n    } else {\n      createWatcher(vm, key, handler);\n    }\n  }\n}\n\nexport function initSateMixin(Vue) {\n  // 扩展$nextTick方法\n  Vue.prototype.$nextTick = nextTick;\n\n  // watch最终调用的$watch方法\n  // options参数可以是 dep: true深度监听;immediate立即执行\n  Vue.prototype.$watch = function (exprOrFn, cb, options = {}) {\n    // console.log(\"$watch\", exprOrFn, cb);\n\n    // 'firstname' 字符串需要转换成() => vm.firstname；在什么地方转？在Watcher里面转\n    // 当firstname变化的时候，就执行cb\n    // { user: true }用户自定义的watcher\n    new Watcher(this, exprOrFn, { user: true }, cb);\n  };\n}\n","// 创建元素的虚拟节点\n//  _h() _c()方法\nexport function createElementVNode(vm, tag, data, ...children) {\n  if (data == null) {\n    data = {};\n  }\n  // react是叫props；vue里是data\n  let key = data.key;\n  if (key) {\n    delete data.key;\n  }\n  return vnode(vm, tag, data, key, children);\n}\n\n// 创建文本的虚拟节点\n// _v()\nexport function createTextVNode(vm, text) {\n  return vnode(vm, undefined, undefined, undefined, undefined, text);\n}\n\n// 虚拟节点vnode\n// key很重要dom diff\nfunction vnode(vm, tag, data, key, children, text) {\n  // vnode上维护了vm属性\n  return {\n    vm,\n    tag,\n    data,\n    key,\n    children,\n    text,\n  };\n}\n\n// AST和VDom一样么?\n// 区别一：描述的范围不一样\n// VDOM和AST很像，但是他描述的信息更多\n// AST可以描述 js css html；描述语言本身 https://astexplorer.net/\n// VDOM只能描述dom\n// 区别二：是否可以增加一些属性\n// AST是语法层面的转化，描述的是语法本身，不可以增加一些属性，原本有什么就转换什么\n// VDom是描述DOM的元素，可以增加一些自定义属性，例如事件、指令、插槽\n\nexport function isSameVnode(vnode1, vnode2) {\n  return vnode1.tag === vnode2.tag && vnode1.key === vnode2.key;\n}\n","import { isSameVnode } from \"./index\";\n\n// 把虚拟DOM转换成真实DOM\nexport function createElm(vnode) {\n  let { tag, children, key, data, text } = vnode;\n  // 根据标签名tag来创建原生元素\n  // 标签\n  if (typeof tag === \"string\") {\n    // 虚拟节点上挂真实DOM节点\n    // 这里将虚拟DOM节点和真实DOM节点对应起来，后续如果修改属性了，可以找到真实DOM\n    vnode.el = document.createElement(tag);\n    // 没有老的props\n    patchProps(vnode.el, {}, data);\n    // 处理儿子\n    children.forEach((child) => {\n      // 儿子需要append到当前的el中\n      return vnode.el.appendChild(createElm(child));\n    });\n  } else {\n    vnode.el = document.createTextNode(text);\n  }\n  return vnode.el;\n}\n\n// 比较props\n// el 当前的真实节点\n// oldProps 老的属性\n// newProps 新的属性\n// 1. 老的有新的没有，就需要删掉老的\n// 2. 老的没有新的有，就需要追加\n// 3. 老的有新的也有，就替换成新的属性值\nexport function patchProps(el, oldProps = {}, newProps = {}) {\n  // 1. 老的有新的没有，就需要删掉老的\n  // 属性 <div a=1\n  for (let key in oldProps) {\n    if (!newProps[key]) {\n      el.removeAttribute(key);\n    }\n  }\n  // 1. 老的有新的没有，就需要删掉老的\n  // style属性 <div a=1 style=\"color: red;\"\n  let oldStyle = oldProps.style;\n  let newStyle = newProps.style;\n  for (let key in oldStyle) {\n    if (!newStyle[key]) {\n      el.style[key] = \"\";\n    }\n  }\n\n  // 2. 无论如何都要用新的覆盖掉老的；但是需要老的有新的没有的需要删掉，就是上面的逻辑\n  // 老的没有新的有，就需要追加\n  // 老的有新的也有，就替换成新的属性值\n  for (let key in newProps) {\n    if (key === \"style\") {\n      for (let styleName in newProps.style) {\n        el.style[styleName] = newProps.style[styleName];\n      }\n    } else if (key === \"class\") {\n      el.className = newProps.class;\n    } else {\n      // 给这个元素添加属性 值就是对应的值\n      el.setAttribute(key, newProps[key]);\n    }\n  }\n}\n\n// 首次渲染和DOM DIFF\nexport function patch(oldVnode, vnode) {\n  // oldVnodes是el，原生DOM就是首次渲染\n  const isRealElement = oldVnode.nodeType;\n  if (isRealElement) {\n    // 首次渲染\n    // 获取真实DOM\n    const oldElm = oldVnode;\n    // 获取真实DOM的父容器\n    const parentElm = oldElm.parentNode;\n\n    let el = createElm(vnode);\n\n    // 先把新的节点插入到老节点的下面\n    parentElm.insertBefore(el, oldElm.nextSibling);\n    // 再删除老节点\n    parentElm.removeChild(oldVnode);\n\n    return el;\n  } else {\n    // DOM DIFF\n    // 1. 两个节点不是同一个节点就直接删除老的换上新的(没有对比了)\n    // 2. 两个节点是同一个节点(判断节点tag和key) 比较两个节点的属性是否有差异（复用老的节点，将差异的属性更新）\n    // 3. 节点比较完毕就要比较两人的儿子\n    return patchVnode(oldVnode, vnode);\n  }\n}\n\nfunction patchVnode(oldVnode, vnode) {\n  // tag === tag && key === key\n  if (!isSameVnode(oldVnode, vnode)) {\n    let el = createElm(vnode);\n    // 老节点的父亲替换自己的儿子为新的节点\n    oldVnode.el.parentNode.replaceChild(el, oldVnode.el);\n    return el;\n  }\n\n  // 文本节点的tag和key都是undefined；undefined === undefined\n  // 文本节点：需要比较下文本的内容\n  // 复用老的文本节点的元素\n  let el = (vnode.el = oldVnode.el);\n  if (!oldVnode.tag) {\n    if (oldVnode.text !== vnode.text) {\n      // 用新的文本替换掉老的文本\n      oldVnode.el.textContent = vnode.text;\n    }\n  }\n\n  // 是标签 同一个标签需要比对标签的属性\n  patchProps(el, oldVnode.data, vnode.data);\n\n  // 比较儿子节点 比较的时候\n  // 1. 一方有儿子一方没有儿子 老的有新的没有就把老的儿子节点全都删掉；老的没有新的有就需要把新的儿子都追加到老的里面\n  // 2. 两方都有儿子\n\n  let oldChildren = oldVnode.children || [];\n  let newChildren = vnode.children || [];\n\n  if (oldChildren.length > 0 && newChildren.length > 0) {\n    // 完整的diff算法，需要比较两人的儿子\n    updateChildren(el, oldChildren, newChildren);\n  } else if (oldChildren.length === 0 && newChildren.length > 0) {\n    // 没有老的，有新的的；用新的append到el里面\n    mountChildren(el, newChildren);\n  } else if (oldChildren.length > 0 && newChildren.length === 0) {\n    // 老的有，新的没有；就删掉老的\n    // innerHTML清空孩子，也可以循环删除\n    // 源码中还需要考虑组件的情况，需要销毁组件\n    el.innerHTML = \"\";\n  }\n\n  return el;\n}\n\nfunction mountChildren(el, newChildren) {\n  for (let i = 0; i < newChildren.length; i++) {\n    el.appendChild(createElm(newChildren[i]));\n  }\n}\n\nfunction updateChildren(el, oldChildren, newChildren) {\n  // 比较新旧老儿子，为了增高性能，我们会有一些优化手段；不要从新的拿出来一个和老的挨个比\n  // 我们操作列表经常是 push pop shift unshift reverse sort等这些方法\n  // 我们需要针对这些场景做些优化： 不是在表头就是表尾操作，最差的是 reverse sort\n  // vue2采用的是双指针的方式，比较两个节点\n  // console.log(oldChildren, newChildren);\n  let oldStartIndex = 0;\n  let newStartIndex = 0;\n  let oldEndIndex = oldChildren.length - 1;\n  let newEndIndex = newChildren.length - 1;\n\n  let oldStartVnode = oldChildren[0];\n  let newStartVnode = newChildren[0];\n  let oldEndVnode = oldChildren[oldEndIndex];\n  let newEndVnode = newChildren[newEndIndex];\n  // console.log(oldStartVnode, oldEndVnode);\n\n  function makeIndexByKey(children) {\n    // 键值为key，值为索引\n    let map = {};\n    children.forEach((item, index) => {\n      map[item.key] = index;\n    });\n    return map;\n  }\n  // 将oldChildren转换成map映射表\n  // 对所有的孩子元素进行编号\n  let map = makeIndexByKey(oldChildren);\n\n  // 面试题：循环的时候为什么加key? 给动态列表添加key的时候劲量不要写index,因为索引前后都是以0开始，可能会发生错误复用\n  // &&有任何一个不满足则停止 ||有一个尾true就继续\n  while (oldStartIndex <= oldEndIndex && newStartIndex <= newEndIndex) {\n    // 只要双方有一方头指针大于尾部指针则退出循环\n    // 只要有一方不满足条件就退出\n\n    // 在乱序比对中如果老的某个节点被标识为了undefined，则老的开始和结束节点在往后往前移动的过程中需要跳过\n    // 遇到undefined就跳过，最后会删除\n    if (!oldStartVnode) {\n      oldStartVnode = oldChildren[++oldStartIndex];\n    } else if (!oldEndVnode) {\n      oldEndVnode = oldChildren[--oldEndIndex];\n    }\n\n    // 比较开头节点 头头比对\n    if (isSameVnode(oldStartVnode, newStartVnode)) {\n      // 如果是相同节点，则递归比较子节点\n      // 递归比较子节点\n      patchVnode(oldStartVnode, newStartVnode);\n      // 然后新旧头部指针后移一位\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newStartVnode = newChildren[++newStartIndex];\n    } else if (isSameVnode(oldEndVnode, newEndVnode)) {\n      // 开头节点不相等就比较结尾节点 尾尾比较\n      // 比较结尾节点 尾尾比对\n      // 如果是相同节点，则递归比较子节点\n      patchVnode(oldEndVnode, newEndVnode);\n      // 然后新旧尾部指针前移一位\n      oldEndVnode = oldChildren[--oldEndIndex];\n      newEndVnode = newChildren[--newEndIndex];\n    } else if (isSameVnode(oldEndVnode, newStartVnode)) {\n      // 交叉比对： 头头不一样，尾尾不一样，就老头和新尾比，老尾和新头\n\n      // 尾移头\n\n      // abcd => dabc 尾部要移动到头部\n      // diff-7.jpeg\n\n      // 如果是相同节点，则递归比较子节点\n      patchVnode(oldEndVnode, newStartVnode);\n      // 复用老的节点： 把老的最后一个节点移动到老的开始节点的前面；把尾移动到了头部\n      // insertBefore具有移动性，会将原来的元素移动走\n      // 先移动元素在移动指针\n      el.insertBefore(oldEndVnode.el, oldStartVnode.el);\n      // 然后旧的尾部指针前移\n      oldEndVnode = oldChildren[--oldEndIndex];\n      // 然后新的头部指针后移\n      newStartVnode = newChildren[++newStartIndex];\n    } else if (isSameVnode(oldStartVnode, newEndVnode)) {\n      // 交叉比对： 头头不一样，尾尾不一样，就老头和新尾比，老尾和新头\n\n      // 头移尾\n\n      // abcd => bcda  头部移动到头尾部\n      // diff-8.jpeg\n\n      // 如果是相同节点，则递归比较子节点\n      patchVnode(oldStartVnode, newEndVnode);\n      // 复用老的节点： 把老的第一个节点移动到老的结束节点的下一个节点（null）后面；把头移动到了尾部\n      // oldEndVnode.el.nextSibling是null\n      // insertBefore具有移动性，会将原来的元素移动走\n      // insertBefore当第二个参数是null的时候相当于appendChild\n      el.insertBefore(oldStartVnode.el, oldEndVnode.el.nextSibling);\n      oldStartVnode = oldChildren[++oldStartIndex];\n      newEndVnode = newChildren[--newEndIndex];\n    } else {\n      // 乱序比对（头头、尾尾、头尾、尾头都比对不上）：这就优化不了了，肯定需要映射\n      // diff-11.jpeg\n      // 算法思路：\n      // 根据老的children做一个映射表；\n      // 用新的去找，找到则移动，并打个标识标识要删除（undefined）（不能删除，否则会导致数组塌陷）\n      // 找不到则创建新的添加并插入到头指针的前面（一直都是插入到头指针的前面）；\n      // 最后多余的就删除\n\n      // 用新的元素去老的中进行查找，如果找到则移动，找不到则直接插入\n      // 老的映射里面有我要移动的索引\n      let moveIndex = map[newStartVnode.key];\n      // 有的话做移动操作\n      if (moveIndex !== undefined) {\n        // 找到对应的虚拟节点复用\n        let moveVnode = oldChildren[moveIndex];\n        // 移动都是移动到老节点的开始节点的前面\n        el.insertBefore(moveVnode.el, oldStartVnode.el);\n        // 标识为undefined，表示这个节点已经移动走了，不能删除，否则会导致数组塌陷，因为循环的过程中删除会影响原本的数组长度\n        oldChildren[moveIndex] = undefined;\n        // 比较属性和递归比较子节点\n        patchVnode(moveVnode, newStartVnode);\n      } else {\n        // 老的中没有则创建一个新元素并插入到老节点的前面\n        el.insertBefore(createElm(newStartVnode), oldStartVnode.el);\n      }\n      // 新节点的开始节点向后移动\n      newStartVnode = newChildren[++newStartIndex];\n    }\n  }\n\n  // 退出上面循环： 有一方已经越界，有一方已经比较完毕\n  // diff-2.jpeg（新的后面多几个节点）和diff-4.jpeg（新的前面多几个节点） 都会走到这里\n  // diff-2.jpeg 如果老的节点oldStartIndex已经越界了，新的后面还有几个节点就插进去后面；比完后新的后面有多余的就插入到后面\n  // diff-4.jpeg 如果老的节点的oldEndIndex已经越界了，新的前面还有几个节点就插入到前面；比完后新的前面有多余的就插入到前面\n  if (newStartIndex <= newEndIndex) {\n    // newStartIndex和newEndIndex之间可能有一个节点，也可能多个节点\n    for (let i = newStartIndex; i <= newEndIndex; i++) {\n      // 这里可能是向后追加也可能是向前追加\n\n      let childEl = createElm(newChildren[i]);\n\n      /*\n      if (newChildren[++newEndIndex]) {\n        // diff-4.jpeg\n        // 头部插入，尾指针挪到了前面\n        el.insertBefore(childEl, newChildren[++newEndIndex].el);\n      } else {\n        // diff-2.jpeg\n        // 尾部插入，因为尾指针后面已经没有元素了\n        el.appendChild(createElm(newChildren[i]));\n      }\n      */\n\n      // 上面的简单写法\n      // 参照物\n      let anchor = newChildren[newEndIndex + 1]\n        ? newChildren[newEndIndex + 1].el\n        : null;\n      // anchor为null的时候则认为会是appendChild\n      el.insertBefore(childEl, anchor);\n    }\n  }\n\n  // diff-3.jpeg 如果新的已经越界，老的后面还剩几个就都删除\n  // 老的多了，老的有剩余\n  // 退出上面循环： 有一方已经比较完毕-新的比较完毕，老的有剩余\n  // 乱序比对的删除也会走到这里\n  // 如果有剩余则直接删除\n  if (oldStartIndex <= oldEndIndex) {\n    for (let i = oldStartIndex; i <= oldEndIndex; i++) {\n      // 虚拟节点上维护着el\n      let child = oldChildren[i];\n      // 因为可能在乱序比对的过程中标识成了undefined\n      if (child != undefined) {\n        // 虚拟节点上维护着el\n        parent.removeChild(child.el);\n      }\n    }\n  }\n}\n","import Watcher from \"./observe/watcher\";\nimport { createElementVNode, createTextVNode } from \"./vdom\";\nimport { patch } from \"./vdom/patch\";\n\nexport function initLifeCycle(Vue) {\n  // 把_render函数生成的虚拟DOM，生成真实DOM\n  Vue.prototype._update = function (vnode) {\n    // console.log(\"_update\", vnode);\n    const vm = this;\n    const el = vm.$el;\n\n    // console.log(\"el\", el);\n\n    // patch既有初始化的功能，又有更新的功能\n    vm.$el = patch(el, vnode);\n  };\n\n  // 生成虚拟DOM\n  Vue.prototype._render = function () {\n    // console.log(\"_render\");\n    let vm = this;\n    // 渲染的时候会从实例vm上取值，我们就将属性和视图绑定在了一起\n    // 为什么要call?希望render函数里面的with的this指向vm\n    // 为啥要指向vm?因为vm上有name，有age\n    // console.log(vm.age, vm.name);\n    // let render = `with(this){return ${code}}`;\n    let vnode = vm.$options.render.call(vm); // 通过ast语法转以后生成的render函数\n    return vnode;\n  };\n\n  // 创建文本\n  //  _v(text),\n  Vue.prototype._v = function (text) {\n    return createTextVNode(this, text);\n  };\n\n  // 创建元素\n  // _c('div', {}, ...children)\n  Vue.prototype._c = function () {\n    return createElementVNode(this, ...arguments);\n  };\n\n  // 把传入的值val转成字符串\n  Vue.prototype._s = function (val) {\n    return val == null\n      ? \"\"\n      : typeof val === \"object\"\n      ? JSON.stringify(val)\n      : val;\n  };\n}\n\nexport function mountComponent(vm, el) {\n  // 这里的el是通过querySelector处理过的\n  vm.$el = el;\n  // 1. 调用render方法，生成虚拟DOM\n  // 2. 根据虚拟DOM，生成真实DOM\n\n  // vm._update(vm._render()); // vm.$options.render();\n\n  // 更新根组件\n  const updateComponent = function () {\n    vm._update(vm._render());\n  };\n\n  // 首次渲染的时候会收集依赖\n  // 更新的时候会再次收集\n  // updateComponent会立即执行\n  let watcher = new Watcher(vm, updateComponent, true); // true标识一个渲染watcher\n  // console.log(watcher);\n\n  // 2. 根据虚拟DOM，生成真实DOM\n\n  // 3. 把真实DOM插入到el元素中\n}\n\n// vue的核心：\n// 1）创建响应式数据\n// 2）模板转换成ast语法树\n// 3）将ast语法树转换成render函数, 调用render方法，生成虚拟DOM\n// 4）后续每次数据更新，只需要执行render函数，无需再次执行ast转换的过程\n\n// render函数会产生虚拟DOM(使用响应式数据)\n// 根据虚拟DOM，生成真实DOM\n\n// 调用钩子函数\nexport function callHook(vm, hook) {\n  const handlers = vm.$options[hook];\n  if (handlers) {\n    handlers.forEach((handler) => handler.call(vm));\n  }\n}\n","import { initState } from \"./state\";\nimport { compileToFunctions } from \"./compiler\";\nimport { callHook, mountComponent } from \"./lifecycle\";\nimport { mergeOptions } from \"./utils\";\n\nexport function initMixin(Vue) {\n  // 通过原型prototype给Vue增加init方法\n  Vue.prototype._init = function (options) {\n    // 用于初始化操作\n    // vue vm.$options就是获取用户的配置\n\n    // 我们使用vue的时候，$nextTick, $data, $attr...以$开头的都表示Vue的内置属性\n    const vm = this;\n\n    // 用全局options(Vue.options)和用户的options来合并merge\n    // 我们定义的全局指令和过滤器等等都会挂载到实例上\n    vm.$options = mergeOptions(this.constructor.options, options); // 将用户的选项挂载到实例上\n\n    // 在initState之前调用beforeCreate\n    callHook(vm, \"beforeCreate\");\n\n    // 初始化状态；初始化计算属性；初始化watch\n    initState(vm);\n\n    // 在initState之后调用created\n    callHook(vm, \"created\");\n\n    if (options.el) {\n      vm.$mount(options.el); // 实现数据的挂载\n    }\n  };\n\n  // 挂载应用\n  Vue.prototype.$mount = function (el) {\n    const vm = this;\n    const options = vm.$options;\n    el = document.querySelector(el);\n\n    // 整体思想：不一定非得有render函数，没有render函数就用template编译成render函数\n    // 先查找有没有render函数\n    if (!options.render) {\n      // 没有render函数的话，再看下是否写了template，写了template就用写了的template\n      // 没有template采用el外部的html\n      let template = options.template;\n      // 没有写template但是写了el\n      if (!template && el) {\n        // 包括el在内的html就是template\n        template = el.outerHTML;\n      }\n\n      // 将模版template编译成render函数\n      const render = compileToFunctions(template); // render函数就是包含h(xxx)\n      options.render = render;\n    }\n\n    // 最终在这里就可以拿到options.render的函数\n    // runtime和runtimeWithComplier\n    // script引用的vue.global.js这个编译过程是在浏览器中执行的\n    // runtime运行时是不包含模板编译的，整个编译是在打包的过程中通过loader编译.vue文件的；\n    // 用runtime的时候不能使用template\n\n    // console.log(\"render\", options.render);\n\n    // 挂载组件\n    mountComponent(vm, el);\n  };\n}\n","import { compileToFunctions } from \"./compiler\";\nimport { initGlobalAPI } from \"./globalAPI\";\nimport { initMixin } from \"./init\";\nimport { initLifeCycle } from \"./lifecycle\";\nimport { initSateMixin } from \"./state\";\nimport { createElm, patch } from \"./vdom/patch\";\n\n// 将所有的方法都耦合在一起\nfunction Vue(options) {\n  // options就是用户的选项\n  this._init(options);\n}\n\ninitMixin(Vue); // 扩展了_init方法\ninitLifeCycle(Vue); // 扩展了生命周期方法 vm._update vm._render方法\ninitGlobalAPI(Vue); // 全局api的实现\ninitSateMixin(Vue); // 实现了$nextTick和$watch方法\n\n// ------------为了方便观察前后的虚拟节点--测试的\n\n// 1 新后面追加\n// let render1 = compileToFunctions(\n//   `<ul a=\"1\" style=\"color: red;\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//   </ul>`\n// );\n\n// 2 老的后面删除\n// let render1 = compileToFunctions(\n//   `<ul a=\"1\" style=\"color: red;\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n//     <li key=\"E\">E</li>\n//   </ul>`\n// );\n\n// 3 在前面追加\n// let render1 = compileToFunctions(\n//   `<ul a=\"1\" style=\"color: red;\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//   </ul>`\n// );\n\n// 4 老的前面删除\n// let render1 = compileToFunctions(\n//   `<ul a=\"1\" style=\"color: red;\">\n//     <li key=\"D\">D</li>\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//   </ul>`\n// );\n\n// 5 老的尾部移动到头部\n// let render1 = compileToFunctions(\n//   `<ul a=\"1\" style=\"color: red;\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n//   </ul>`\n// );\n\n// 6 老的头移动到尾部\n// let render1 = compileToFunctions(\n//   `<ul a=\"1\" style=\"color: red;\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n//   </ul>`\n// );\n\n// 7 命中特殊的场景优化 ABCD => DCBA 会移动三次\n// 头尾 尾头 同事处理了倒序和排序的情况\n// let render1 = compileToFunctions(\n//   `<ul a=\"1\" style=\"color: red;\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n//   </ul>`\n// );\n\n// 8\nlet render1 = compileToFunctions(\n  `<ul a=\"1\" style=\"color: red;\">\n    <li key=\"A\">A</li>\n    <li key=\"B\">B</li>\n    <li key=\"C\">C</li>\n    <li key=\"D\">D</li>\n  </ul>`\n);\n\nlet vm1 = new Vue({ data: { name: \"zuopf1\" } });\nlet preVnode = render1.call(vm1);\n\nlet el = createElm(preVnode);\ndocument.body.appendChild(el);\n\n// console.log(\"preVnode\", preVnode);\n\n// 1\n// let render2 = compileToFunctions(\n//   `<ul style=\"color: yellow;background:blue\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n//     <li key=\"E\">E</li>\n//   </ul>`\n// );\n\n// 2\n// let render2 = compileToFunctions(\n//   `<ul style=\"color: yellow;background:blue\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//   </ul>`\n// );\n\n// 3\n// let render2 = compileToFunctions(\n//   `<ul style=\"color: yellow;background:blue\">\n//     <li key=\"D\">D</li>\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//   </ul>`\n// );\n\n// 4\n// let render2 = compileToFunctions(\n//   `<ul style=\"color: yellow;background:blue\">\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//   </ul>`\n// );\n\n// 5\n// let render2 = compileToFunctions(\n//   `<ul style=\"color: yellow;background:blue\">\n//     <li key=\"D\">D</li>\n//     <li key=\"A\">A</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//   </ul>`\n// );\n\n// 6\n// let render2 = compileToFunctions(\n//   `<ul style=\"color: yellow;background:blue\">\n//     <li key=\"B\">B</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"D\">D</li>\n//     <li key=\"A\">A</li>\n//   </ul>`\n// );\n\n// 7\n// let render2 = compileToFunctions(\n//   `<ul style=\"color: yellow;background:blue\">\n//     <li key=\"D\">D</li>\n//     <li key=\"C\">C</li>\n//     <li key=\"B\">B</li>\n//     <li key=\"A\">A</li>\n//   </ul>`\n// );\n\nlet render2 = compileToFunctions(\n  `<ul style=\"color: yellow;background:blue\">\n    <li key=\"B\">B</li>\n    <li key=\"M\">M</li>\n    <li key=\"A\">A</li>\n    <li key=\"P\">P</li>\n    <li key=\"C\">C</li>\n    <li key=\"Q\">Q</li>\n  </ul>`\n);\nlet vm2 = new Vue({ data: { name: \"zuopf2\" } });\nlet nextVnode = render2.call(vm2);\n// console.log(\"nextVnode\", nextVnode);\n\n// let newEl = createElm(nextVnode);\n// el.parentNode.replaceChild(newEl.el);\n\n// 直接更新: 直接用新的节点替换了老的节点\n// 直接替换的性能问题: console.log(dir(dom)) dom节点上有很多属性；获取dom并不消耗性能，重要的是\n// DOM Diff: 不是直接替换，而是比较两个人的区别之后再替换\n// Diff算法的思想：diff算法是一个平级比较的过程，父亲和父亲比，儿子和儿子比对\nsetTimeout(() => {\n  // let newel = createElm(nextVnode);\n  // el.parentNode.replaceChild(newel, el);\n  // DOM Diff\n  patch(preVnode, nextVnode);\n}, 1000);\n\nexport default Vue;\n"],"names":["ncname","qnameCapture","concat","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","stack","ELEMENT_TYPE","TEXT_TYPE","root","currentParent","createASTElement","tagName","attrs","tag","type","children","parent","start","element","push","end","pop","length","chars","text","replace","advance","n","substring","parseStartTag","match","attr","name","value","textEnd","indexOf","startTagMatch","endTagMatch","defaultTagRE","gen","node","codegen","test","JSON","stringify","tokens","lastIndex","exec","index","slice","trim","join","getChildren","el","map","c","genProps","str","_loop","i","obj","split","forEach","item","_item$split","_item$split2","_slicedToArray","key","code","compileToFunctions","template","ast","render","renderFn","Function","strats","LIFECYCLES","hook","p","mergeOptions","child","options","hasOwnProperty","mergeField","initGlobalAPI","Vue","mixin","oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","method","_len","arguments","args","_key","result","apply","ob","__ob__","inserted","observeArray","dep","notify","id","Dep","_classCallCheck","subs","_createClass","depend","target","addDep","addSubs","watcher","update","pushTarget","popTarget","Observer","defineProperty","enumerable","configurable","isArray","__proto__","walk","data","keys","defineReactive","observe","dependArray","current","childOb","get","set","newValue","_typeof","Watcher","vm","exprOrFn","cb","renderWatcher","getter","deps","depsId","Set","lazy","dirty","user","undefined","evaluate","call","depId","has","add","queueWatcher","run","oldValue","queue","pending","flushSchedulerQueue","flushQueue","q","setTimeout","callbacks","waiting","flushCallbacks","cbs","timerFunc","Promise","resolve","then","MutationObserver","observer","textNode","document","createTextNode","characterData","textContent","setImmediate","nextTick","initState","opts","$options","initData","computed","initComputed","watch","initWatch","proxy","_data","watchers","_computedWatchers","userDef","fn","defineComputed","setter","createComputedGetter","createWatcher","handler","$watch","initSateMixin","$nextTick","createElementVNode","vnode","createTextVNode","isSameVnode","vnode1","vnode2","createElm","createElement","patchProps","appendChild","oldProps","newProps","removeAttribute","oldStyle","style","newStyle","styleName","className","setAttribute","patch","oldVnode","isRealElement","nodeType","oldElm","parentElm","parentNode","insertBefore","nextSibling","removeChild","patchVnode","replaceChild","oldChildren","newChildren","updateChildren","mountChildren","innerHTML","oldStartIndex","newStartIndex","oldEndIndex","newEndIndex","oldStartVnode","newStartVnode","oldEndVnode","newEndVnode","makeIndexByKey","moveIndex","moveVnode","childEl","anchor","initLifeCycle","_update","$el","_render","_v","_c","_s","val","mountComponent","updateComponent","callHook","handlers","initMixin","_init","constructor","$mount","querySelector","outerHTML","render1","vm1","preVnode","body","render2","vm2","nextVnode"],"mappings":"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"}