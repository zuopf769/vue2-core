{"version":3,"file":"vue.js","sources":["../src/observe/array.js","../src/observe/index.js","../src/state.js","../src/compiler/parse.js","../src/compiler/index.js","../src/lifecycle.js","../src/init.js","../src/index.js"],"sourcesContent":["// 我们希望重新数组的部分方法\n// 思路： 改变原型链、AOP函数劫持：内部调用原本的方法前后新加逻辑\n\n// 获取数组的原型\nlet oldArrayProtoMethods = Array.prototype;\n\n// 基于Array.prototype创建一个新的对象\n// 让数组类型的value的__proto__指向下面的对象，等于修改了原型链\n// arrayMethods.__proto__ = oldArrayProtoMethods;\n// value.__proto__ == arrayMethods\nexport let arrayMethods = Object.create(oldArrayProtoMethods);\n\n// 所有的变异方法7个：能修改原数组的方法： 对头（尾）\n// concat、slice不能修改原数组\nlet methods = [\"push\", \"pop\", \"shift\", \"unshift\", \"reverse\", \"sort\", \"splice\"];\n\nmethods.forEach((method) => {\n  // arrayMethods上面的加的方法只会影响arrayMethods上面的方法，不会覆盖Array.prototype上的原本的方法\n  // 通过原型链找到了arrayMethods的push就不会继续去找Array.prototype上的push方法\n  // 重新arrayMethods上的7个方法\n  // arr.push(1,2,3)\n  arrayMethods[method] = function (...args) {\n    // 这里重写了数组的方法\n    // 旧方法: 在新的方法里面调用\n    // this就是arr\n    const result = oldArrayProtoMethods[method].apply(this, args); // 内部调用原来的方法，函数的劫持，面向切片变成\n\n    console.log(\"array method: \", method);\n\n    // 底下为AOP的增加自己的逻辑\n\n    // this是arr，谁调用的push就是谁\n    // this就是Observer中的那个value\n    const ob = this.__ob__;\n    // 新增的数组\n    let inserted;\n    // push和unshift会新增数据，新增的数据也需要劫持\n    // splice也可能会新增数据\n    switch (method) {\n      case \"push\":\n      case \"unshift\":\n        inserted = args; // arr.unshift(1, 2, 3) // 新增的内容是一个数组\n        break;\n      case \"splice\":\n        inserted = args.slice(2); // arr.splice(0, 1, {a: 1}, {b: 2}) 第2个参数后面的参数是新增的内容是数组\n      default:\n        break;\n    }\n    // 对数组类型的数据进行观察劫持\n    if (inserted) ob.observeArray(inserted); // 对新增的数据（数组）再次进行观测劫持\n    return result;\n  };\n});\n","import { arrayMethods } from \"./array\";\nclass Observer {\n  // 观测值\n  constructor(value) {\n    // 给所有响应式数据增加标识，并且可以在响应式上获取Observer实例上的方法\n    // 如果数据上已经有了__ob__标识，证明已经被代理过了\n    // 增加__ob__属性为this，目的是可以在value上取到this从而调用Observer类上的方法\n    // 等同于value.__ob__ = this；但是没有控制可以枚举性，会导致下面defineReactive的时候死循环\n    // 值是this，但是不可枚举，循环的时候无法获取，从而解决了死循环的问题\n    Object.defineProperty(value, \"__ob__\", {\n      enumerable: false,\n      configurable: false,\n      value: this,\n    });\n\n    if (Array.isArray(value)) {\n      // 重新数组的7个变异方法，为啥是变异方法，因为会修改原数组\n\n      // 需要保留数组原有的方法，并且可以重写部分方法\n      value.__proto__ = arrayMethods; // 重写数组原型方法\n      // 数组里面的对象引用类型也需要进行劫持\n      this.observeArray(value); // 如果数组中方的是对象，可以监控到对象的改变\n    } else {\n      // 遍历\n      this.walk(value);\n    }\n  }\n\n  // 循环递归（性能差的原因）对象，对对象的所有属性进行劫持\n  walk(data) {\n    // 让对象上的所有属性依次进行观测\n    let keys = Object.keys(data);\n    for (let i = 0; i < keys.length; i++) {\n      let key = keys[i];\n      let value = data[key];\n      // \"重新定义\"属性\n      defineReactive(data, key, value);\n    }\n  }\n\n  // 观测数组\n  observeArray(data) {\n    data.forEach((item) => observe(item));\n  }\n}\n\n// 要暴露的方法，所以不能放到Observer类里面\n// 闭包\nexport function defineReactive(data, key, value) {\n  // 深度属性劫持\n  // 如果value还是object类型，继续调用observe进行递归劫持\n  observe(value);\n\n  // 缺点：Object.defineProperty只能劫持已经存在的属性，对于新增的和删除的操作监听不到\n  // 所以vue中单独写了一些api如$set, $delete来实现属性的新增的和删除后，仍然能做到数据劫持\n  Object.defineProperty(data, key, {\n    get() {\n      console.log(`get key ${key}`);\n\n      // 取值的时候会执行get\n      // 闭包，value不会销毁，能取得到\n      return value;\n    },\n    set(newValue) {\n      // 设值的时候会执行set\n      if (newValue == value) return;\n\n      console.log(`set key ${key} ${newValue}`);\n\n      // 再次劫持\n      // 深度属性劫持\n      // 如果设置的属性的value仍然是对象，继续递归进行新增属性的响应式\n      observe(newValue);\n\n      value = newValue;\n    },\n  });\n}\n\nexport function observe(data) {\n  // 对这个对象进行劫持\n\n  if (typeof data !== \"object\" || data === null) {\n    return; // 只对对象进行劫持\n  }\n\n  // data上有__ob__标识证明已经被观察过了，直接返回原本的Observer就可以了\n  if (data.__ob__ instanceof Observer) {\n    return data.__ob__;\n  }\n\n  // 如果一个对象被劫持过了，那就不需要再被劫持了（需要判断一个对象是否被劫持过，可以添加一个实例，用实例来判断是否被劫持过）\n  return new Observer(data);\n}\n","import { observe } from \"./observe\";\n\nexport function initState(vm) {\n  const opts = vm.$options; // 获取所有的选项\n\n  if (opts.data) {\n    initData(vm);\n  }\n}\n\n// 数据代理\nfunction proxy(vm, target, key) {\n  // vm.name\n  Object.defineProperty(vm, key, {\n    get() {\n      // => vm._data.name\n      return vm[target][key];\n    },\n    set(newValue) {\n      vm[target][key] = newValue;\n    },\n  });\n}\n\n// 初始化data\nfunction initData(vm) {\n  let data = vm.$options.data; // data可能是函数和对象\n  // 根组件可以是function也可以对象，组件必须是函数\n  data = typeof data === \"function\" ? data.call(vm) : data; // data是用户返回的对象\n  // 将data挂载到vm的_data，和vm上直接可以取到属性的proxy不一样\n  vm._data = data;\n  // 数据劫持 vue2用的是Object.defineProperty\n  observe(data);\n\n  // vm.xxx =>(代理到)  vm._data.xxx\n  for (let key in data) {\n    proxy(vm, \"_data\", key);\n  }\n}\n","// 标签名：第一个字符+后面的字符；第一个字符不能以数字开头\n// 字符串的两个\\\\是什么？表示转义，字符串中的转义，前一个\\表示转义后面的\\\nconst ncname = `[a-zA-Z_][\\\\-\\\\.0-9_a-zA-Z]*`;\n// (?:${ncname}\\\\:)?\n// 第一个?:表示匹配但是不记住匹配项；\n// 为啥不要记住匹配性，因为需要加()分组后表示前面一半是命名空间可有可无，但是又不想铺获$1的值\n// https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_expressions#special-non-capturing-parentheses\n// (?:${ncname}\\\\:)? 第二个？表示可有可无\n// 外面的分组\nconst qnameCapture = `((?:${ncname}\\\\:)?${ncname})`;\n\n// 注意前面的开头^，必须是开始匹配\n// <1_xxx 不能以数字开头\n// <_xxx 自定义标签，都是以_开头 webcomponent\n// <xxx\n// <namespace:yyy 命名空间\nconst startTagOpen = new RegExp(`^<${qnameCapture}`); // 标签开头的正则 捕获的内容是标签名\n// console.log(startTagOpen);\n\n// 注意前面的开头^，必须是开始匹配\n// 匹配到的是</xxx>\nconst endTag = new RegExp(`^<\\\\/${qnameCapture}[^>]*>`); // 匹配标签结尾的 </div>\n// console.log(endTag);\n\n// 注意前面的开头^，必须是开始匹配\n// a=b 没有空格\n// a = b =前后有空格\n// <xx a = b a前面也有空格\n// ([^\\s\"'<>\\/=]+)表示前面的属性名或者属性值，除了\"'<>那些字符都可以的字符\n// <xxx disabled disabled属性只有前面的部分没有后面的部分（=xxx）\n// (?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))? 第一个()为了后面加？表示属性值可有可无\n// \"([^\"]*)\"+ 以双引号包的非\"的多个字符 <xx a = \"b\" 左边双引号右边双引号中间不是双引号就可以\n// '([^']*)'+ 以单引号包的非'的多个字符 <xx a = 'b' 左边单引号右边单引号中间不是单引号就可以\n// ([^\\s\"'=<>`]+) 除了\\s\"'=<>`的任意多个字符  <xx a = b 属性也可以不加单引号或者双引号\nconst attribute =\n  /^\\s*([^\\s\"'<>\\/=]+)(?:\\s*(=)\\s*(?:\"([^\"]*)\"+|'([^']*)'+|([^\\s\"'=<>`]+)))?/; // 匹配属性的\n// 第一个分组就是属性的key value就是分组3/分组4/分组5\nconsole.log(attribute);\n\n// 注意前面的开头^，必须是开始匹配\n// <div> <br/> 标签结束可能是> 也可能是/>\nconst startTagClose = /^\\s*(\\/?)>/; // 匹配标签结束的 >\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // {{aaaaaa}} 匹配到的时候表达式的变量\n\n// 对模版进行编译\n// vue3不是采用的正则匹配了，是一个一个字符匹配\n// 思路： 每解析一个标签就删除一个标签，每解析一个属性就删除一个属性；字符串被截取完了就结束了\nexport function parseHTML(html) {\n  // 抽象语法树\n  /*\n  {\n    tag:'div',\n    type:1,\n    children:[{tag:'span',type:1,attrs:[],parent:'div对象'}],\n    attrs:[{name:'zf',age:10}],\n    parent:null\n  }\n*/\n\n  // 用于存放元素的栈，利用栈来创建一棵树\n  let stack = [];\n  // 节点类型-标签类型\n  const ELEMENT_TYPE = 1;\n  // 节点类型-文本类型\n  const TEXT_TYPE = 3;\n  // 根节点\n  let root;\n  // 指向栈中最后一个元素\n  let currentParent;\n\n  function createASTElement(tagName, attrs) {\n    return {\n      tag: tagName,\n      type: ELEMENT_TYPE,\n      children: [],\n      attrs,\n      parent: null,\n    };\n  }\n\n  // 开始标签 <div><span><a>text</a></span></div>\n  function start(tagName, attrs) {\n    // console.log(tagName, attrs);\n    // 创建一个ast节点\n    let element = createASTElement(tagName, attrs);\n    // 看下是否是空树\n    if (!root) {\n      // 如果为空树，当前节点是树的根节点\n      root = element;\n    }\n    // 进栈构建父子关系\n    // 放在end时候执行该逻辑也行\n    // if (currentParent) {\n    //   element.parent = currentParent;\n    //   currentParent.children.push(element);\n    // }\n    stack.push(element);\n    // currentParent为栈中的最后一个元素\n    currentParent = element;\n  }\n\n  // 结束标签\n  function end(tagName) {\n    // console.log(tagName);\n    // 当前标签结束就弹栈；弹出栈中的最后一个元素\n    let element = stack.pop();\n    // currentParent为栈中的最后一个元素\n    currentParent = stack[stack.length - 1];\n    // 出栈构建父子关系\n    // 放在start入栈的时候执行该逻辑也行\n    if (currentParent) {\n      // 当前标签结束的这个元素的parent就是栈中的最后一个元素\n      element.parent = currentParent;\n      // 栈中的最后一个元素的儿子就是当前弹栈弹出来的节点\n      currentParent.children.push(element);\n    }\n  }\n\n  // 文本；文本不需要放到栈中，文本直接放到currentParent节点的children中\n  function chars(text) {\n    // console.log(text);\n    // 去掉空，可以优化为如果空格超过2个就删除2个以上的空格\n    text = text.replace(/\\s/g, \"\");\n    // 不是节点直接的换行等空文本\n    if (text) {\n      // 文本节点直接放到当前栈的最后一个节点的children中，作为他的儿子\n      currentParent.children.push({\n        type: TEXT_TYPE,\n        text,\n        parent: currentParent,\n      });\n    }\n  }\n\n  // html字符串前进n个字符：例如截掉已经捕获到的开头标签名、属性名和属性值、结束标签\n  function advance(n) {\n    html = html.substring(n);\n  }\n\n  // 解析开始标签，包括解析标签名和所有属性\n  function parseStartTag() {\n    // 匹配开始标签名\n    const start = html.match(startTagOpen);\n    if (start) {\n      const match = {\n        tagName: start[1],\n        attrs: [],\n      };\n\n      // html字符串截掉tagName\n      // start[0] =>\n      advance(start[0].length);\n\n      // 捕获当前标签的所有属性\n      let attr, end;\n      // 当前捕获到了属性标签并且不是当前标签的结束\n      while (\n        !(end = html.match(startTagClose)) &&\n        (attr = html.match(attribute))\n      ) {\n        match.attrs.push({\n          name: attr[1],\n          value: attr[3] || attr[4] || attr[5],\n        });\n        // attr[0] => id=\"app\"\n        advance(attr[0].length);\n      }\n\n      // html字符当前到了当前标签的结束位置 > 或者 />\n      if (end) {\n        // 移除结束位置\n        advance(end[0].length);\n        // 返回匹配到的当前节点\n        return match;\n      }\n    }\n  }\n\n  // html字符串肯定是以<开头\n  while (html) {\n    let textEnd = html.indexOf(\"<\");\n    // <div>hello</div> indexOf等于0\n    // 如果textEnd为0，表明当前html字符串处于开始标签处或者结束标签处\n    // 如果textEnd大于0，表明当前html字符串处于文本节点或者空文本处，>处于文本节点的结束位置\n    if (textEnd === 0) {\n      // 如果indexOf的索引是0，则说明是一个开始标签或者结束标签\n      // 解析开始标签：<div a=b c=d>\n      const startTagMatch = parseStartTag();\n      if (startTagMatch) {\n        start(startTagMatch.tagName, startTagMatch.attrs);\n        // 继续解析当前标签下的子开头标签\n        // 例如<div a=b c=d><span>txt</span></div>中的下一个标签是<span>\n        continue;\n      }\n\n      // 解析到最深的子节点的结束标签\n      // 例如<div a=b c=d><span>txt</span></div>中的</span>\n      const endTagMatch = html.match(endTag);\n      if (endTagMatch) {\n        advance(endTagMatch[0].length);\n        end(endTagMatch[1]);\n        continue;\n      }\n      // 先让他暂停\n      // break;\n    }\n\n    // 当前html字符串处于文本标签处，因为结束标签>的index>0\n    // 标签中的空格也是文本\n    // <div a=b c=d>\n    //    <span>txt</span>\n    // </div>\n    // hello</div> indexOf大于0 说明是文本\n    let text;\n    if (textEnd > 0) {\n      text = html.substring(0, textEnd);\n    }\n    if (text) {\n      advance(text.length);\n      chars(text);\n    }\n  }\n\n  // html为空\n  // console.log(\"html\", html);\n  // root\n  // console.log(\"root\", root);\n\n  return root;\n}\n","import { parseHTML } from \"./parse\";\n\nconst defaultTagRE = /\\{\\{((?:.|\\r?\\n)+?)\\}\\}/g; // {{aaaaaa}} 匹配到的时候表达式的变量\n\n/**\n *\n *  <div style=\"color:red\">hello {{name}} <span></span></div>\n *  render(){\n *    return _c('div',{style:{color:'red'}},_v('hello'+_s(name) + 'age' + _s(age)),_c('span',undefined,''))\n *  }\n */\n\n// 如果是文本就创建文本节点；如果是标签元素就调用codegen\nfunction gen(node) {\n  // 标签类型\n  if (node.type == 1) {\n    return codegen(node);\n  } else {\n    // 文本类型节点\n    let text = node.text;\n    // 纯文本类型\n    if (!defaultTagRE.test(text)) {\n      return `_v(${JSON.stringify(text)})`;\n    }\n    // 包含{{}}的类型\n    // 变量name需要转成字符串_s(name) 用+拼接\n    // {{name}} hello {{name}} => _v(_s(name) + 'hello' + _s(name))\n    console.log(\"文本节点：\", text);\n\n    let tokens = [];\n    let match;\n    // exec方法的特殊点：\n    // 现象：当正则表达式里面有g的时候，连续执行两次结果不一样: let reg = /a/g; reg.exec('abc'); reg.exec('abc');\n    // 原因：执行完一次后 reg.lastIndex变成1了，从第一个字符再往后找就找不到了\n    // 解决方法：每次重新执行exec的时候需要把reg.lastIndex重置为0\n    defaultTagRE.lastIndex = 0;\n    // 记录上一个匹配内容后的位置，算上字符串本身的长度\n    let lastIndex = 0;\n    while ((match = defaultTagRE.exec(text))) {\n      // console.log(\"match\", match);\n      // 匹配的位置\n      let index = match.index;\n\n      // 中间有一个文本字符串\n      // {{name}} hello {{age}} age\n      // lastIndex就是{{name}}的结尾位置，index就是{{name}}的开头位置\n      if (index > lastIndex) {\n        // 把中间的hello内容放到tokens中\n        tokens.push(JSON.stringify(text.slice(lastIndex, index)));\n      }\n\n      tokens.push(`_s(${match[1].trim()})`);\n      lastIndex = index + match[0].length;\n    }\n\n    // 最后的文本字符串\n    // {{name}} hello {{age}} age中的age\n    // 从{{age}}的结束位置截取到最后\n    if (text.length > lastIndex) {\n      tokens.push(JSON.stringify(text.slice(lastIndex)));\n    }\n\n    // console.log(tokens);\n\n    return `_v(${tokens.join(\"+\")})`;\n  }\n}\n\n// 生成儿子节点\nfunction getChildren(el) {\n  const children = el.children;\n  if (children) {\n    return `${children.map((c) => gen(c)).join(\",\")}`;\n  } else {\n    return false;\n  }\n}\n\n// 生成属性\n// attrs [{name: 'id', value: 'wapper'}, {name: 'style', value: 'color: red; font-size: 50px'}]\nfunction genProps(attrs) {\n  let str = \"\";\n  for (let i = 0; i < attrs.length; i++) {\n    const attr = attrs[i];\n    // 如果attr名称是style\n    // {name: 'style', value: 'color: red; font-size: 50px'}\n    // 'color: red; font-size: 50px' => {color: red, font-size: 50px}\n    if (attr.name === \"style\") {\n      let obj = {};\n      attr.value.split(\";\").forEach((item) => {\n        let [key, value] = item.split(\":\");\n        obj[key] = value;\n      });\n      attr.value = obj;\n    }\n    // JSON.stringify把vue转成字符串\n    str += `${attr.name}:${JSON.stringify(attr.value)},`;\n  }\n  return `{${str.slice(0, -1)}}`;\n}\n\n// 生成code\nfunction codegen(el) {\n  // console.log(\"el\", el);\n\n  // 生成改节点的孩子，如果有孩子就加个,没孩子就不加了\n  let children = getChildren(el);\n\n  let code = `_c('${el.tag}', ${\n    el.attrs.length > 0 ? genProps(el.attrs) : \"undefined\"\n  }${children ? `,${children}` : \"\"}\n  )`;\n\n  return code;\n}\n\nexport function compileToFunctions(template) {\n  // console.log(template);\n\n  // 1. 将template转换成AST语法树\n  let ast = parseHTML(template);\n  // console.log(ast);\n\n  // 2. 生成render方法，render方法执行后返回的结果就是虚拟DOM\n  let code = codegen(ast);\n  // console.log(\"code\", code);\n\n  // 模版引擎的原理： with + new Function\n  // _c('div',{style:{color:'red'}},_v('hello'+_s(name)),_c('span',undefined,''))\n  // 用with？为了取值方便；解决_c _v _s从哪儿取的问题，不用都得vm._c vm._v vm._s了\n  // 为啥是this而不是vm? render函数被谁调用就是谁； this是谁就从谁的上面取_c _v _s\n  let render = `with(this){return ${code}}`;\n  let renderFn = new Function(render);\n  // 生成render函数，需要调用；分成两块：生成函数、调用函数\n  return renderFn;\n}\n\n// 最终的render函数\n/*\nfunction render() {\n  with (this) {\n    _c(\n      \"div\",\n      { style: { color: \"red\" } },\n      _v(\"hello\" + _s(name)),\n      _c(\"span\", undefined, \"\")\n    );\n  }\n}\n*/\n\n// render函数调用绑定作用域\n// render.call(vm);\n","export function initLifeCycle(Vue) {\n  // 生成真实DOM\n  Vue.prototype._update = function () {\n    console.log(\"_update\");\n  };\n  // 生成虚拟DOM\n  Vue.prototype._render = function () {\n    console.log(\"_render\");\n  };\n}\n\nexport function mountComponent(vm, el) {\n  // 1. 调用render方法，生成虚拟DOM\n  // 2. 根据虚拟DOM，生成真实DOM\n  vm._update(vm._render()); // vm.$options.render();\n\n  // 2. 根据虚拟DOM，生成真实DOM\n\n  // 3. 把真实DOM插入到el元素中\n}\n\n// vue的核心：\n// 1）创建响应式数据\n// 2）模板转换成ast语法树\n// 3）将ast语法树转换成render函数, 调用render方法，生成虚拟DOM\n// 4）后续每次数据更新，只需要执行render函数，无需再次执行ast转换的过程\n\n// render函数会产生虚拟DOM(使用响应式数据)\n// 根据虚拟DOM，生成真实DOM\n","import { initState } from \"./state\";\nimport { compileToFunctions } from \"./compiler\";\nimport { initLifeCycle, mountComponent } from \"./lifecycle\";\n\nexport function initMixin(Vue) {\n  // 通过原型prototype给Vue增加init方法\n  Vue.prototype._init = function (options) {\n    // 用于初始化操作\n    // vue vm.$options就是获取用户的配置\n\n    // 我们使用vue的时候，$nextTick, $data, $attr...以$开头的都表示Vue的内置属性\n    const vm = this;\n    vm.$options = options; // 将用户的选项挂载到实例上\n\n    // 初始化状态\n    initState(vm);\n\n    if (options.el) {\n      vm.$mount(options.el); // 实现数据的挂载\n    }\n  };\n\n  // 挂载应用\n  Vue.prototype.$mount = function (el) {\n    const vm = this;\n    const options = vm.$options;\n    el = document.querySelector(el);\n\n    // 整体思想：不一定非得有render函数，没有render函数就用template编译成render函数\n    // 先查找有没有render函数\n    if (!options.render) {\n      // 没有render函数的话，再看下是否写了template，写了template就用写了的template\n      // 没有template采用el外部的html\n      let template = options.template;\n      // 没有写template但是写了el\n      if (!template && el) {\n        // 包括el在内的html就是template\n        template = el.outerHTML;\n      }\n\n      // 将模版template编译成render函数\n      const render = compileToFunctions(template); // render函数就是包含h(xxx)\n      options.render = render;\n    }\n\n    // 最终在这里就可以拿到options.render的函数\n    // runtime和runtimeWithComplier\n    // script引用的vue.global.js这个编译过程是在浏览器中执行的\n    // runtime运行时是不包含模板编译的，整个编译是在打包的过程中通过loader编译.vue文件的；\n    // 用runtime的时候不能使用template\n\n    console.log(\"render\", options.render);\n\n    // 挂载组件\n    mountComponent(vm, el);\n  };\n}\n","import { initMixin } from \"./init\";\nimport { initLifeCycle } from \"./lifecycle\";\n\n// 将所有的方法都耦合在一起\nfunction Vue(options) {\n  // options就是用户的选项\n  this._init(options);\n}\n\ninitMixin(Vue); // 扩展了_init方法\ninitLifeCycle(Vue); // 扩展了生命周期方法\n\nexport default Vue;\n"],"names":["oldArrayProtoMethods","Array","prototype","arrayMethods","Object","create","methods","forEach","method","_len","arguments","length","args","_key","result","apply","console","log","ob","__ob__","inserted","slice","observeArray","Observer","value","_classCallCheck","defineProperty","enumerable","configurable","isArray","__proto__","walk","_createClass","key","data","keys","i","defineReactive","item","observe","get","concat","set","newValue","_typeof","initState","vm","opts","$options","initData","proxy","target","call","_data","ncname","qnameCapture","startTagOpen","RegExp","endTag","attribute","startTagClose","parseHTML","html","stack","ELEMENT_TYPE","TEXT_TYPE","root","currentParent","createASTElement","tagName","attrs","tag","type","children","parent","start","element","push","end","pop","chars","text","replace","advance","n","substring","parseStartTag","match","attr","name","textEnd","indexOf","startTagMatch","endTagMatch","defaultTagRE","gen","node","codegen","test","JSON","stringify","tokens","lastIndex","exec","index","trim","join","getChildren","el","map","c","genProps","str","_loop","obj","split","_item$split","_item$split2","_slicedToArray","code","compileToFunctions","template","ast","render","renderFn","Function","initLifeCycle","Vue","_update","_render","mountComponent","initMixin","_init","options","$mount","document","querySelector","outerHTML"],"mappings":"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"}